{"ast":null,"code":"var url = require(\"url\");\n\nvar Immutable = require(\"immutable\");\n\nmodule.exports.init = function (ui, bs) {\n  var validUrls = Immutable.OrderedSet();\n  var methods = {\n    /**\n     * Send the url list to UI\n     * @param urls\n     */\n    sendUpdatedUrls: function (urls) {\n      ui.socket.emit(\"ui:history:update\", decorateUrls(urls));\n    },\n\n    /**\n     * Only send to UI if list changed\n     * @param current\n     * @param temp\n     */\n    sendUpdatedIfChanged: function (current, temp) {\n      if (!Immutable.is(current, temp)) {\n        validUrls = temp;\n        methods.sendUpdatedUrls(validUrls);\n      }\n    },\n\n    /**\n     * Send all clients to a URL - this is a proxy\n     * in case we need to limit/check anything.\n     * @param data\n     */\n    sendToUrl: function (data) {\n      var parsed = url.parse(data.path);\n      data.override = true;\n      data.path = parsed.path;\n      data.url = parsed.href;\n      ui.clients.emit(\"browser:location\", data);\n    },\n\n    /**\n     * Add a new path\n     * @param data\n     */\n    addPath: function (data) {\n      var temp = addPath(validUrls, url.parse(data.href), bs.options.get(\"mode\"));\n      methods.sendUpdatedIfChanged(validUrls, temp, ui.socket);\n    },\n\n    /**\n     * Remove a path\n     * @param data\n     */\n    removePath: function (data) {\n      var temp = removePath(validUrls, data.path);\n      methods.sendUpdatedIfChanged(validUrls, temp, ui.socket);\n    },\n\n    /**\n     * Get the current list\n     */\n    getVisited: function () {\n      ui.socket.emit(\"ui:receive:visited\", decorateUrls(validUrls));\n    }\n  };\n  ui.clients.on(\"connection\", function (client) {\n    client.on(\"ui:history:connected\", methods.addPath);\n  });\n  ui.socket.on(\"connection\", function (uiClient) {\n    /**\n     * Send urls on first connection\n     */\n    uiClient.on(\"ui:get:visited\", methods.getVisited);\n    methods.sendUpdatedUrls(validUrls);\n  });\n  ui.listen(\"history\", {\n    \"sendAllTo\": methods.sendToUrl,\n    \"remove\": methods.removePath,\n    \"clear\": function () {\n      validUrls = Immutable.OrderedSet([]);\n      methods.sendUpdatedUrls(validUrls);\n    }\n  });\n  return methods;\n};\n/**\n * @param {Immutable.Set} urls\n * @returns {Array}\n */\n\n\nfunction decorateUrls(urls) {\n  var count = 0;\n  return urls.map(function (value) {\n    count += 1;\n    return {\n      path: value,\n      key: count\n    };\n  }).toJS().reverse();\n}\n/**\n * If snippet mode, add the full URL\n * if server/proxy, add JUST the path\n * @param immSet\n * @param urlObj\n * @param mode\n * @returns {Set}\n */\n\n\nfunction addPath(immSet, urlObj, mode) {\n  return immSet.add(mode === \"snippet\" ? urlObj.href : urlObj.path);\n}\n\nmodule.exports.addPath = addPath;\n/**\n * @param immSet\n * @param urlPath\n * @returns {*}\n */\n\nfunction removePath(immSet, urlPath) {\n  return immSet.remove(url.parse(urlPath).path);\n}\n\nmodule.exports.removePath = removePath;","map":{"version":3,"names":["url","require","Immutable","module","exports","init","ui","bs","validUrls","OrderedSet","methods","sendUpdatedUrls","urls","socket","emit","decorateUrls","sendUpdatedIfChanged","current","temp","is","sendToUrl","data","parsed","parse","path","override","href","clients","addPath","options","get","removePath","getVisited","on","client","uiClient","listen","count","map","value","key","toJS","reverse","immSet","urlObj","mode","add","urlPath","remove"],"sources":["/Users/johnberetty/node_modules/browser-sync-ui/lib/plugins/history/history.js"],"sourcesContent":["var url       = require(\"url\");\nvar Immutable = require(\"immutable\");\n\nmodule.exports.init = function (ui, bs) {\n\n    var validUrls = Immutable.OrderedSet();\n\n    var methods = {\n        /**\n         * Send the url list to UI\n         * @param urls\n         */\n        sendUpdatedUrls: function (urls) {\n            ui.socket.emit(\"ui:history:update\", decorateUrls(urls));\n        },\n        /**\n         * Only send to UI if list changed\n         * @param current\n         * @param temp\n         */\n        sendUpdatedIfChanged: function (current, temp) {\n            if (!Immutable.is(current, temp)) {\n                validUrls = temp;\n                methods.sendUpdatedUrls(validUrls);\n            }\n        },\n        /**\n         * Send all clients to a URL - this is a proxy\n         * in case we need to limit/check anything.\n         * @param data\n         */\n        sendToUrl: function (data) {\n\n            var parsed = url.parse(data.path);\n\n            data.override = true;\n            data.path = parsed.path;\n            data.url  = parsed.href;\n\n            ui.clients.emit(\"browser:location\", data);\n        },\n        /**\n         * Add a new path\n         * @param data\n         */\n        addPath: function (data) {\n            var temp = addPath(validUrls, url.parse(data.href), bs.options.get(\"mode\"));\n            methods.sendUpdatedIfChanged(validUrls, temp, ui.socket);\n        },\n        /**\n         * Remove a path\n         * @param data\n         */\n        removePath: function (data) {\n            var temp = removePath(validUrls, data.path);\n            methods.sendUpdatedIfChanged(validUrls, temp, ui.socket);\n        },\n        /**\n         * Get the current list\n         */\n        getVisited: function () {\n            ui.socket.emit(\"ui:receive:visited\", decorateUrls(validUrls));\n        }\n    };\n\n    ui.clients.on(\"connection\", function (client) {\n        client.on(\"ui:history:connected\", methods.addPath);\n    });\n\n    ui.socket.on(\"connection\", function (uiClient) {\n        /**\n         * Send urls on first connection\n         */\n        uiClient.on(\"ui:get:visited\",    methods.getVisited);\n        methods.sendUpdatedUrls(validUrls);\n    });\n\n    ui.listen(\"history\", {\n        \"sendAllTo\": methods.sendToUrl,\n        \"remove\":    methods.removePath,\n        \"clear\":     function () {\n            validUrls = Immutable.OrderedSet([]);\n            methods.sendUpdatedUrls(validUrls);\n        }\n    });\n\n    return methods;\n};\n\n/**\n * @param {Immutable.Set} urls\n * @returns {Array}\n */\nfunction decorateUrls (urls) {\n    var count = 0;\n    return urls.map(function (value) {\n        count += 1;\n        return {\n            path: value,\n            key: count\n        };\n    }).toJS().reverse();\n}\n\n/**\n * If snippet mode, add the full URL\n * if server/proxy, add JUST the path\n * @param immSet\n * @param urlObj\n * @param mode\n * @returns {Set}\n */\nfunction addPath(immSet, urlObj, mode) {\n    return immSet.add(\n        mode === \"snippet\"\n            ? urlObj.href\n            : urlObj.path\n    );\n}\n\nmodule.exports.addPath = addPath;\n\n/**\n * @param immSet\n * @param urlPath\n * @returns {*}\n */\nfunction removePath(immSet, urlPath) {\n    return immSet.remove(url.parse(urlPath).path);\n}\n\nmodule.exports.removePath = removePath;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}