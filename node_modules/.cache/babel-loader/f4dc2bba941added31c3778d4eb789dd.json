{"ast":null,"code":"\"use strict\";\n\nvar utils = require(\"./lib/utils\");\n\nvar debug = require(\"debug\")(\"resp-mod\");\n\nfunction RespModifier(opts) {\n  // options\n  opts = opts || {};\n  opts.blacklist = utils.toArray(opts.blacklist) || [];\n  opts.whitelist = utils.toArray(opts.whitelist) || [];\n  opts.hostBlacklist = utils.toArray(opts.hostBlacklist) || [];\n  opts.rules = opts.rules || [];\n  opts.ignore = opts.ignore || opts.excludeList || utils.defaultIgnoreTypes; // helper functions\n\n  opts.regex = function () {\n    var matches = opts.rules.map(function (item) {\n      return item.match.source;\n    }).join(\"|\");\n    return new RegExp(matches);\n  }();\n\n  var respMod = this;\n  respMod.opts = opts;\n  respMod.middleware = respModifierMiddleware;\n\n  respMod.update = function (key, value) {\n    if (respMod.opts[key]) {\n      respMod.opts[key] = value;\n    }\n\n    return respMod;\n  };\n\n  function respModifierMiddleware(req, res, next) {\n    if (res._respModifier) {\n      debug(\"Reject req\", req.url);\n      return next();\n    }\n\n    debug(\"Accept req\", req.url);\n    res._respModifier = true;\n    var writeHead = res.writeHead;\n    var runPatches = true;\n    var write = res.write;\n    var end = res.end;\n    var singlerules = utils.isWhiteListedForSingle(req.url, respMod.opts.rules);\n    var withoutSingle = respMod.opts.rules.filter(function (rule) {\n      if (rule.paths && rule.paths.length) {\n        return false;\n      }\n\n      return true;\n    });\n    /**\n     * Exit early for blacklisted domains\n     */\n\n    if (respMod.opts.hostBlacklist.indexOf(req.headers.host) > -1) {\n      return next();\n    }\n\n    if (singlerules.length) {\n      modifyResponse(singlerules, true);\n    } else {\n      if (utils.isWhitelisted(req.url, respMod.opts.whitelist)) {\n        modifyResponse(withoutSingle, true);\n      } else {\n        if (!utils.hasAcceptHeaders(req) || utils.inBlackList(req.url, respMod.opts)) {\n          debug(\"Black listed or no text/html headers\", req.url);\n          return next();\n        } else {\n          modifyResponse(withoutSingle);\n        }\n      }\n    }\n\n    next();\n    /**\n     * Actually do the overwrite\n     * @param {Array} rules\n     * @param {Boolean} [force] - if true, will always attempt to perform\n     * an overwrite - regardless of whether it appears to be HTML or not\n     */\n\n    function modifyResponse(rules, force) {\n      req.headers[\"accept-encoding\"] = \"identity\";\n\n      function restore() {\n        res.writeHead = writeHead;\n        res.write = write;\n        res.end = end;\n      }\n\n      res.push = function (chunk) {\n        res.data = (res.data || \"\") + chunk;\n      };\n\n      res.write = function (string, encoding) {\n        if (!runPatches) {\n          return write.call(res, string, encoding);\n        }\n\n        if (string !== undefined) {\n          var body = string instanceof Buffer ? string.toString(encoding) : string; // If this chunk appears to be valid, push onto the res.data stack\n\n          if (force || utils.isHtml(body) || utils.isHtml(res.data)) {\n            res.push(body);\n          } else {\n            restore();\n            return write.call(res, string, encoding);\n          }\n        }\n\n        return true;\n      };\n\n      res.writeHead = function () {\n        if (!runPatches) {\n          return writeHead.apply(res, arguments);\n        }\n\n        var headers = arguments[arguments.length - 1];\n\n        if (typeof headers === \"object\") {\n          for (var name in headers) {\n            if (/content-length/i.test(name)) {\n              delete headers[name];\n            }\n          }\n        }\n\n        if (res.getHeader(\"content-length\")) {\n          res.removeHeader(\"content-length\");\n        }\n\n        writeHead.apply(res, arguments);\n      };\n\n      res.end = function (string, encoding) {\n        res.data = res.data || \"\";\n\n        if (typeof string === \"string\") {\n          res.data += string;\n        }\n\n        if (string instanceof Buffer) {\n          res.data += string.toString();\n        }\n\n        if (!runPatches) {\n          return end.call(res, string, encoding);\n        } // Check if our body is HTML, and if it does not already have the snippet.\n\n\n        if (force || utils.isHtml(res.data) && !utils.snip(res.data)) {\n          // Include, if necessary, replacing the entire res.data with the included snippet.\n          res.data = utils.applyRules(rules, res.data, req, res);\n          runPatches = false;\n        }\n\n        if (res.data !== undefined && !res._header) {\n          res.setHeader(\"content-length\", Buffer.byteLength(res.data, encoding));\n        }\n\n        end.call(res, res.data, encoding);\n      };\n    }\n  }\n\n  return respMod;\n}\n\nmodule.exports = function (opts) {\n  var resp = new RespModifier(opts);\n  return resp.middleware;\n};\n\nmodule.exports.create = function (opts) {\n  var resp = new RespModifier(opts);\n  return resp;\n};\n\nmodule.exports.utils = utils;","map":{"version":3,"names":["utils","require","debug","RespModifier","opts","blacklist","toArray","whitelist","hostBlacklist","rules","ignore","excludeList","defaultIgnoreTypes","regex","matches","map","item","match","source","join","RegExp","respMod","middleware","respModifierMiddleware","update","key","value","req","res","next","_respModifier","url","writeHead","runPatches","write","end","singlerules","isWhiteListedForSingle","withoutSingle","filter","rule","paths","length","indexOf","headers","host","modifyResponse","isWhitelisted","hasAcceptHeaders","inBlackList","force","restore","push","chunk","data","string","encoding","call","undefined","body","Buffer","toString","isHtml","apply","arguments","name","test","getHeader","removeHeader","snip","applyRules","_header","setHeader","byteLength","module","exports","resp","create"],"sources":["/Users/johnberetty/node_modules/resp-modifier/index.js"],"sourcesContent":["\"use strict\";\n\nvar utils     = require(\"./lib/utils\");\nvar debug     = require(\"debug\")(\"resp-mod\");\n\nfunction RespModifier (opts) {\n\n    // options\n    opts               = opts || {};\n    opts.blacklist     = utils.toArray(opts.blacklist)     || [];\n    opts.whitelist     = utils.toArray(opts.whitelist)     || [];\n    opts.hostBlacklist = utils.toArray(opts.hostBlacklist) || [];\n    opts.rules         = opts.rules                        || [];\n    opts.ignore        = opts.ignore || opts.excludeList   || utils.defaultIgnoreTypes;\n\n    // helper functions\n    opts.regex = (function () {\n        var matches = opts.rules.map(function (item) {\n            return item.match.source;\n        }).join(\"|\");\n        return new RegExp(matches);\n    })();\n\n    var respMod        = this;\n\n    respMod.opts       = opts;\n    respMod.middleware = respModifierMiddleware;\n    respMod.update = function (key, value) {\n        if (respMod.opts[key]) {\n            respMod.opts[key] = value;\n        }\n        return respMod;\n    };\n\n    function respModifierMiddleware(req, res, next) {\n\n        if (res._respModifier) {\n            debug(\"Reject req\", req.url);\n            return next();\n        }\n        debug(\"Accept req\", req.url);\n\n        res._respModifier = true;\n\n        var writeHead   = res.writeHead;\n        var runPatches  = true;\n        var write       = res.write;\n        var end         = res.end;\n        var singlerules = utils.isWhiteListedForSingle(req.url, respMod.opts.rules);\n\n        var withoutSingle = respMod.opts.rules.filter(function (rule) {\n            if (rule.paths && rule.paths.length) {\n                return false;\n            }\n            return true;\n        });\n\n        /**\n         * Exit early for blacklisted domains\n         */\n        if (respMod.opts.hostBlacklist.indexOf(req.headers.host) > -1) {\n            return next();\n        }\n\n        if (singlerules.length) {\n            modifyResponse(singlerules, true);\n        } else {\n            if (utils.isWhitelisted(req.url, respMod.opts.whitelist)) {\n                modifyResponse(withoutSingle, true);\n            } else {\n                if (!utils.hasAcceptHeaders(req) || utils.inBlackList(req.url, respMod.opts)) {\n                    debug(\"Black listed or no text/html headers\", req.url);\n                    return next();\n                } else {\n                    modifyResponse(withoutSingle);\n                }\n            }\n        }\n\n        next();\n\n        /**\n         * Actually do the overwrite\n         * @param {Array} rules\n         * @param {Boolean} [force] - if true, will always attempt to perform\n         * an overwrite - regardless of whether it appears to be HTML or not\n         */\n        function modifyResponse(rules, force) {\n\n            req.headers[\"accept-encoding\"] = \"identity\";\n\n            function restore() {\n                res.writeHead = writeHead;\n                res.write = write;\n                res.end = end;\n            }\n\n            res.push = function (chunk) {\n                res.data = (res.data || \"\") + chunk;\n            };\n\n            res.write = function (string, encoding) {\n\n                if (!runPatches) {\n                    return write.call(res, string, encoding);\n                }\n\n                if (string !== undefined) {\n                    var body = string instanceof Buffer ? string.toString(encoding) : string;\n                    // If this chunk appears to be valid, push onto the res.data stack\n                    if (force || (utils.isHtml(body) || utils.isHtml(res.data))) {\n                        res.push(body);\n                    } else {\n                        restore();\n                        return write.call(res, string, encoding);\n                    }\n                }\n                return true;\n            };\n\n            res.writeHead = function () {\n                if (!runPatches) {\n                    return writeHead.apply(res, arguments);\n                }\n\n                var headers = arguments[arguments.length - 1];\n\n                if (typeof headers === \"object\") {\n                    for (var name in headers) {\n                        if (/content-length/i.test(name)) {\n                            delete headers[name];\n                        }\n                    }\n                }\n\n                if (res.getHeader(\"content-length\")) {\n                    res.removeHeader(\"content-length\");\n                }\n\n                writeHead.apply(res, arguments);\n            };\n\n            res.end = function (string, encoding) {\n\n                res.data = res.data || \"\";\n\n                if (typeof string === \"string\") {\n                    res.data += string;\n                }\n\n                if (string instanceof Buffer) {\n                    res.data += string.toString();\n                }\n\n                if (!runPatches) {\n                    return end.call(res, string, encoding);\n                }\n\n                // Check if our body is HTML, and if it does not already have the snippet.\n                if (force || utils.isHtml(res.data) && !utils.snip(res.data)) {\n                    // Include, if necessary, replacing the entire res.data with the included snippet.\n                    res.data = utils.applyRules(rules, res.data, req, res);\n                    runPatches = false;\n                }\n                if (res.data !== undefined && !res._header) {\n                    res.setHeader(\"content-length\", Buffer.byteLength(res.data, encoding));\n                }\n                end.call(res, res.data, encoding);\n            };\n        }\n    }\n\n    return respMod;\n}\n\nmodule.exports = function (opts) {\n    var resp = new RespModifier(opts);\n    return resp.middleware;\n};\n\nmodule.exports.create = function (opts) {\n    var resp = new RespModifier(opts);\n    return resp;\n};\n\nmodule.exports.utils = utils;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}