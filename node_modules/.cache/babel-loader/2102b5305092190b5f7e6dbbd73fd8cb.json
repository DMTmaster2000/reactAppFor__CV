{"ast":null,"code":"\"use strict\";\n\nvar etag = require(\"etag\");\n\nvar fresh = require(\"fresh\");\n\nvar fs = require(\"fs\");\n\nvar path = require(\"path\");\n\nvar zlib = require(\"zlib\");\n\nvar minifiedScript = path.join(__dirname, \"dist\", \"index.min.js\");\nvar unminifiedScript = path.join(__dirname, \"dist\", \"index.js\");\n/**\n * Does the current request support compressed encoding?\n * @param {Object} req\n * @returns {boolean}\n */\n\nfunction supportsGzip(req) {\n  var accept = req.headers[\"accept-encoding\"];\n  return accept && accept.indexOf(\"gzip\") > -1;\n}\n/**\n * Set headers on the response\n * @param {Object} res\n * @param {String} body\n */\n\n\nfunction setHeaders(res, body) {\n  res.setHeader(\"Cache-Control\", \"public, max-age=0\");\n  res.setHeader(\"Content-Type\", \"text/javascript\");\n  res.setHeader(\"ETag\", etag(body));\n}\n/**\n * @param {Object} req\n * @returns {String}\n */\n\n\nfunction isConditionalGet(req) {\n  return req.headers[\"if-none-match\"] || req.headers[\"if-modified-since\"];\n}\n/**\n * Return a not-modified response\n * @param {Object} res\n */\n\n\nfunction notModified(res) {\n  res.removeHeader(\"Content-Type\");\n  res.statusCode = 304;\n  res.end();\n}\n\nfunction processItems(items) {\n  return [].concat(items).filter(Boolean).reduce((stringOutput, item) => {\n    if (typeof item === 'string') {\n      return stringOutput + item;\n    }\n\n    if (typeof item === 'function') {\n      return stringOutput + item();\n    }\n\n    return stringOutput;\n  }, \"\");\n}\n/**\n * Public method for returning either a middleware fn\n * or the content as a string\n * @param {Object} options\n * @param requestBody\n * @param {String} type - either `file` or `middleware`\n * @returns {*}\n */\n\n\nfunction init(options, requestBody, type) {\n  /**\n   * If the user asked for a file, simply return the string.\n   */\n  if (type && type === \"file\") {\n    return processItems(requestBody);\n  }\n  /**\n   * Otherwise return a function to be used a middleware\n   */\n\n\n  return function (req, res) {\n    /**\n     * default to using the uncompressed string\n     * @type {String}\n     */\n    var output = processItems(requestBody);\n    /**\n     * Set the appropriate headers for caching\n     */\n\n    setHeaders(res, output);\n    var resHeaders = res.getHeaders ? res.getHeaders() : res._headers;\n\n    if (isConditionalGet(req) && fresh(req.headers, resHeaders)) {\n      return notModified(res);\n    }\n    /**\n     * If gzip is supported, compress the string once\n     * and save for future requests\n     */\n\n\n    if (supportsGzip(req)) {\n      res.setHeader(\"Content-Encoding\", \"gzip\");\n      var buf = Buffer.from(output, \"utf-8\");\n      zlib.gzip(buf, function (_, result) {\n        res.end(result);\n      });\n    } else {\n      res.end(output);\n    }\n  };\n}\n\nmodule.exports.middleware = init;\nmodule.exports.plugin = init;\n\nmodule.exports.minified = function () {\n  return fs.readFileSync(minifiedScript, \"utf8\");\n};\n\nmodule.exports.unminified = function () {\n  return fs.readFileSync(unminifiedScript, \"utf8\");\n};","map":{"version":3,"names":["etag","require","fresh","fs","path","zlib","minifiedScript","join","__dirname","unminifiedScript","supportsGzip","req","accept","headers","indexOf","setHeaders","res","body","setHeader","isConditionalGet","notModified","removeHeader","statusCode","end","processItems","items","concat","filter","Boolean","reduce","stringOutput","item","init","options","requestBody","type","output","resHeaders","getHeaders","_headers","buf","Buffer","from","gzip","_","result","module","exports","middleware","plugin","minified","readFileSync","unminified"],"sources":["/Users/johnberetty/node_modules/browser-sync-client/index.js"],"sourcesContent":["\"use strict\";\n\nvar etag = require(\"etag\");\nvar fresh = require(\"fresh\");\nvar fs = require(\"fs\");\nvar path = require(\"path\");\nvar zlib = require(\"zlib\");\n\nvar minifiedScript = path.join(__dirname, \"dist\", \"index.min.js\");\nvar unminifiedScript = path.join(__dirname, \"dist\", \"index.js\");\n\n/**\n * Does the current request support compressed encoding?\n * @param {Object} req\n * @returns {boolean}\n */\nfunction supportsGzip(req) {\n    var accept = req.headers[\"accept-encoding\"];\n    return accept && accept.indexOf(\"gzip\") > -1;\n}\n\n/**\n * Set headers on the response\n * @param {Object} res\n * @param {String} body\n */\nfunction setHeaders(res, body) {\n    res.setHeader(\"Cache-Control\", \"public, max-age=0\");\n    res.setHeader(\"Content-Type\", \"text/javascript\");\n    res.setHeader(\"ETag\", etag(body));\n}\n\n/**\n * @param {Object} req\n * @returns {String}\n */\nfunction isConditionalGet(req) {\n    return req.headers[\"if-none-match\"] || req.headers[\"if-modified-since\"];\n}\n\n/**\n * Return a not-modified response\n * @param {Object} res\n */\nfunction notModified(res) {\n    res.removeHeader(\"Content-Type\");\n    res.statusCode = 304;\n    res.end();\n}\n\nfunction processItems(items) {\n    return [].concat(items)\n        .filter(Boolean)\n        .reduce((stringOutput, item) => {\n            if (typeof item === 'string') {\n                return stringOutput + item;\n            }\n            if (typeof item === 'function') {\n                return stringOutput + item();\n            }\n            return stringOutput;\n        }, \"\");\n}\n\n/**\n * Public method for returning either a middleware fn\n * or the content as a string\n * @param {Object} options\n * @param requestBody\n * @param {String} type - either `file` or `middleware`\n * @returns {*}\n */\nfunction init(options, requestBody, type) {\n    /**\n     * If the user asked for a file, simply return the string.\n     */\n    if (type && type === \"file\") {\n        return processItems(requestBody);\n    }\n\n    /**\n     * Otherwise return a function to be used a middleware\n     */\n    return function(req, res) {\n        /**\n         * default to using the uncompressed string\n         * @type {String}\n         */\n        var output = processItems(requestBody);\n\n        /**\n         * Set the appropriate headers for caching\n         */\n        setHeaders(res, output);\n        var resHeaders = res.getHeaders ? res.getHeaders() : res._headers;\n        if (isConditionalGet(req) && fresh(req.headers, resHeaders)) {\n            return notModified(res);\n        }\n\n        /**\n         * If gzip is supported, compress the string once\n         * and save for future requests\n         */\n        if (supportsGzip(req)) {\n            res.setHeader(\"Content-Encoding\", \"gzip\");\n            var buf = Buffer.from(output, \"utf-8\");\n            zlib.gzip(buf, function(_, result) {\n                res.end(result);\n            });\n        } else {\n            res.end(output);\n        }\n    };\n}\n\nmodule.exports.middleware = init;\nmodule.exports.plugin = init;\nmodule.exports.minified = function() {\n    return fs.readFileSync(minifiedScript, \"utf8\");\n};\nmodule.exports.unminified = function() {\n    return fs.readFileSync(unminifiedScript, \"utf8\");\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}