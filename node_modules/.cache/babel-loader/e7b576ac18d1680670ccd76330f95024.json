{"ast":null,"code":"const {\n  EventEmitter\n} = require('events');\n\nconst debug = require('debug')('localtunnel:client');\n\nconst fs = require('fs');\n\nconst net = require('net');\n\nconst tls = require('tls');\n\nconst HeaderHostTransformer = require('./HeaderHostTransformer'); // manages groups of tunnels\n\n\nmodule.exports = class TunnelCluster extends EventEmitter {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(opts);\n    this.opts = opts;\n  }\n\n  open() {\n    const opt = this.opts; // Prefer IP if returned by the server\n\n    const remoteHostOrIp = opt.remote_ip || opt.remote_host;\n    const remotePort = opt.remote_port;\n    const localHost = opt.local_host || 'localhost';\n    const localPort = opt.local_port;\n    const localProtocol = opt.local_https ? 'https' : 'http';\n    const allowInvalidCert = opt.allow_invalid_cert;\n    debug('establishing tunnel %s://%s:%s <> %s:%s', localProtocol, localHost, localPort, remoteHostOrIp, remotePort); // connection to localtunnel server\n\n    const remote = net.connect({\n      host: remoteHostOrIp,\n      port: remotePort\n    });\n    remote.setKeepAlive(true);\n    remote.on('error', err => {\n      debug('got remote connection error', err.message); // emit connection refused errors immediately, because they\n      // indicate that the tunnel can't be established.\n\n      if (err.code === 'ECONNREFUSED') {\n        this.emit('error', new Error(`connection refused: ${remoteHostOrIp}:${remotePort} (check your firewall settings)`));\n      }\n\n      remote.end();\n    });\n\n    const connLocal = () => {\n      if (remote.destroyed) {\n        debug('remote destroyed');\n        this.emit('dead');\n        return;\n      }\n\n      debug('connecting locally to %s://%s:%d', localProtocol, localHost, localPort);\n      remote.pause();\n\n      if (allowInvalidCert) {\n        debug('allowing invalid certificates');\n      }\n\n      const getLocalCertOpts = () => allowInvalidCert ? {\n        rejectUnauthorized: false\n      } : {\n        cert: fs.readFileSync(opt.local_cert),\n        key: fs.readFileSync(opt.local_key),\n        ca: opt.local_ca ? [fs.readFileSync(opt.local_ca)] : undefined\n      }; // connection to local http server\n\n\n      const local = opt.local_https ? tls.connect({\n        host: localHost,\n        port: localPort,\n        ...getLocalCertOpts()\n      }) : net.connect({\n        host: localHost,\n        port: localPort\n      });\n\n      const remoteClose = () => {\n        debug('remote close');\n        this.emit('dead');\n        local.end();\n      };\n\n      remote.once('close', remoteClose); // TODO some languages have single threaded servers which makes opening up\n      // multiple local connections impossible. We need a smarter way to scale\n      // and adjust for such instances to avoid beating on the door of the server\n\n      local.once('error', err => {\n        debug('local error %s', err.message);\n        local.end();\n        remote.removeListener('close', remoteClose);\n\n        if (err.code !== 'ECONNREFUSED') {\n          return remote.end();\n        } // retrying connection to local server\n\n\n        setTimeout(connLocal, 1000);\n      });\n      local.once('connect', () => {\n        debug('connected locally');\n        remote.resume();\n        let stream = remote; // if user requested specific local host\n        // then we use host header transform to replace the host header\n\n        if (opt.local_host) {\n          debug('transform Host header to %s', opt.local_host);\n          stream = remote.pipe(new HeaderHostTransformer({\n            host: opt.local_host\n          }));\n        }\n\n        stream.pipe(local).pipe(remote); // when local closes, also get a new remote\n\n        local.once('close', hadError => {\n          debug('local connection closed [%s]', hadError);\n        });\n      });\n    };\n\n    remote.on('data', data => {\n      const match = data.toString().match(/^(\\w+) (\\S+)/);\n\n      if (match) {\n        this.emit('request', {\n          method: match[1],\n          path: match[2]\n        });\n      }\n    }); // tunnel is considered open when remote connects\n\n    remote.once('connect', () => {\n      this.emit('open', remote);\n      connLocal();\n    });\n  }\n\n};","map":{"version":3,"names":["EventEmitter","require","debug","fs","net","tls","HeaderHostTransformer","module","exports","TunnelCluster","constructor","opts","open","opt","remoteHostOrIp","remote_ip","remote_host","remotePort","remote_port","localHost","local_host","localPort","local_port","localProtocol","local_https","allowInvalidCert","allow_invalid_cert","remote","connect","host","port","setKeepAlive","on","err","message","code","emit","Error","end","connLocal","destroyed","pause","getLocalCertOpts","rejectUnauthorized","cert","readFileSync","local_cert","key","local_key","ca","local_ca","undefined","local","remoteClose","once","removeListener","setTimeout","resume","stream","pipe","hadError","data","match","toString","method","path"],"sources":["/Users/johnberetty/node_modules/localtunnel/lib/TunnelCluster.js"],"sourcesContent":["const { EventEmitter } = require('events');\nconst debug = require('debug')('localtunnel:client');\nconst fs = require('fs');\nconst net = require('net');\nconst tls = require('tls');\n\nconst HeaderHostTransformer = require('./HeaderHostTransformer');\n\n// manages groups of tunnels\nmodule.exports = class TunnelCluster extends EventEmitter {\n  constructor(opts = {}) {\n    super(opts);\n    this.opts = opts;\n  }\n\n  open() {\n    const opt = this.opts;\n\n    // Prefer IP if returned by the server\n    const remoteHostOrIp = opt.remote_ip || opt.remote_host;\n    const remotePort = opt.remote_port;\n    const localHost = opt.local_host || 'localhost';\n    const localPort = opt.local_port;\n    const localProtocol = opt.local_https ? 'https' : 'http';\n    const allowInvalidCert = opt.allow_invalid_cert;\n\n    debug(\n      'establishing tunnel %s://%s:%s <> %s:%s',\n      localProtocol,\n      localHost,\n      localPort,\n      remoteHostOrIp,\n      remotePort\n    );\n\n    // connection to localtunnel server\n    const remote = net.connect({\n      host: remoteHostOrIp,\n      port: remotePort,\n    });\n\n    remote.setKeepAlive(true);\n\n    remote.on('error', err => {\n      debug('got remote connection error', err.message);\n\n      // emit connection refused errors immediately, because they\n      // indicate that the tunnel can't be established.\n      if (err.code === 'ECONNREFUSED') {\n        this.emit(\n          'error',\n          new Error(\n            `connection refused: ${remoteHostOrIp}:${remotePort} (check your firewall settings)`\n          )\n        );\n      }\n\n      remote.end();\n    });\n\n    const connLocal = () => {\n      if (remote.destroyed) {\n        debug('remote destroyed');\n        this.emit('dead');\n        return;\n      }\n\n      debug('connecting locally to %s://%s:%d', localProtocol, localHost, localPort);\n      remote.pause();\n\n      if (allowInvalidCert) {\n        debug('allowing invalid certificates');\n      }\n\n      const getLocalCertOpts = () =>\n        allowInvalidCert\n          ? { rejectUnauthorized: false }\n          : {\n              cert: fs.readFileSync(opt.local_cert),\n              key: fs.readFileSync(opt.local_key),\n              ca: opt.local_ca ? [fs.readFileSync(opt.local_ca)] : undefined,\n            };\n\n      // connection to local http server\n      const local = opt.local_https\n        ? tls.connect({ host: localHost, port: localPort, ...getLocalCertOpts() })\n        : net.connect({ host: localHost, port: localPort });\n\n      const remoteClose = () => {\n        debug('remote close');\n        this.emit('dead');\n        local.end();\n      };\n\n      remote.once('close', remoteClose);\n\n      // TODO some languages have single threaded servers which makes opening up\n      // multiple local connections impossible. We need a smarter way to scale\n      // and adjust for such instances to avoid beating on the door of the server\n      local.once('error', err => {\n        debug('local error %s', err.message);\n        local.end();\n\n        remote.removeListener('close', remoteClose);\n\n        if (err.code !== 'ECONNREFUSED') {\n          return remote.end();\n        }\n\n        // retrying connection to local server\n        setTimeout(connLocal, 1000);\n      });\n\n      local.once('connect', () => {\n        debug('connected locally');\n        remote.resume();\n\n        let stream = remote;\n\n        // if user requested specific local host\n        // then we use host header transform to replace the host header\n        if (opt.local_host) {\n          debug('transform Host header to %s', opt.local_host);\n          stream = remote.pipe(new HeaderHostTransformer({ host: opt.local_host }));\n        }\n\n        stream.pipe(local).pipe(remote);\n\n        // when local closes, also get a new remote\n        local.once('close', hadError => {\n          debug('local connection closed [%s]', hadError);\n        });\n      });\n    };\n\n    remote.on('data', data => {\n      const match = data.toString().match(/^(\\w+) (\\S+)/);\n      if (match) {\n        this.emit('request', {\n          method: match[1],\n          path: match[2],\n        });\n      }\n    });\n\n    // tunnel is considered open when remote connects\n    remote.once('connect', () => {\n      this.emit('open', remote);\n      connLocal();\n    });\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}