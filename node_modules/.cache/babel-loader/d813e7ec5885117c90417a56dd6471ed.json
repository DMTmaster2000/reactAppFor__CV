{"ast":null,"code":"var Immutable = require(\"immutable\");\n\nvar Map = Immutable.Map;\nvar isMap = Immutable.Map.isMap;\nvar List = Immutable.List;\n\nvar qs = require(\"qs\");\n\nvar path = require(\"path\");\n\nvar fs = require(\"fs\");\n\nvar Plugin = Immutable.Record({\n  moduleName: \"\",\n  name: \"\",\n  active: true,\n  module: undefined,\n  options: Map({}),\n  via: \"inline\",\n  dir: process.cwd(),\n  init: undefined,\n  errors: List([])\n});\n/**\n * Accept a string/object\n * and resolve it into the plugin format above\n * @param item\n * @returns {*}\n */\n\nfunction resolvePlugin(item) {\n  /**\n   * Handle when string was given, such as plugins: ['bs-html-injector']\n   */\n  if (typeof item === \"string\") {\n    return getFromString(item);\n  }\n\n  if (!isMap(item)) {\n    return new Plugin().mergeDeep({\n      errors: [new Error(\"Plugin not supported in this format\")]\n    });\n  }\n\n  if (item.has(\"module\")) {\n    var nameOrObj = item.get(\"module\");\n    var options = item.get(\"options\");\n    /**\n     * The 'module' key can be a string, this allows\n     * inline plugin references, but with options\n     * eg:\n     *\n     * bs.init({\n     *     plugins: [\n     *         {\n     *             module: './myjs-file.js'\n     *             options: {\n     *                 files: \"*.html\"\n     *             }\n     *         }\n     *     ]\n     * });\n     */\n\n    if (typeof nameOrObj === \"string\") {\n      return getFromString(nameOrObj).mergeDeep({\n        options: options\n      });\n    }\n    /**\n     * If the plugin was given completely inline (because it needs options)\n     * eg:\n     *\n     * bs.init({\n     *     plugins: [\n     *         {\n     *             module: {\n     *                 plugin: function() {\n     *                     console.log('My plugin code')\n     *                 }\n     *             },\n     *             options: {\n     *                 files: \"*.html\"\n     *             }\n     *         }\n     *     ]\n     * })\n     */\n\n\n    if (Immutable.Map.isMap(nameOrObj)) {\n      return new Plugin({\n        module: nameOrObj,\n        options: options\n      });\n    }\n  }\n  /**\n   * If a module was given directly. For example, ater calling require.\n   *\n   * eg:\n   *    var myplugin = require('./some-js');\n   *    bs.init({plugins: [myplugin]});\n   */\n\n\n  if (item.has(\"plugin\")) {\n    return new Plugin({\n      module: item\n    });\n  }\n  /**\n   * If we reach here, the plugin option was used incorrectly\n   */\n\n\n  return new Plugin().mergeDeep({\n    errors: [new Error(\"Plugin was not configured correctly\")]\n  });\n}\n\nmodule.exports.resolvePlugin = resolvePlugin;\n/**\n * Load a plugin from disk\n * @param item\n * @returns {*}\n */\n\nfunction requirePlugin(item) {\n  /**\n   * if the \"module\" property already exists and\n   * is not a string, then we bail and don't bother looking\n   * for the file\n   */\n  if (item.get(\"module\") && typeof item.get(\"module\") !== \"string\") {\n    return item;\n  }\n\n  try {\n    /**\n     * Try a raw node require() call - this will be how\n     * regular \"npm installed\" plugins wil work\n     */\n    var maybe = require.resolve(item.get(\"name\"));\n\n    return item.set(\"module\", require(maybe));\n  } catch (e) {\n    /**\n     * If require threw an MODULE_NOT_FOUND error, try again\n     * by resolving from cwd. This is needed since cli\n     * users will not add ./ to the front of a path (which\n     * node requires to resolve from cwd)\n     */\n    if (e.code === \"MODULE_NOT_FOUND\") {\n      var maybe = path.resolve(process.cwd(), item.get(\"name\"));\n\n      if (fs.existsSync(maybe)) {\n        return item.set(\"module\", require(maybe));\n      } else {\n        /**\n         * Finally return a plugin that contains the error\n         * this will be picked up later and discarded\n         */\n        return item.update(\"errors\", function (errors) {\n          return errors.concat(e);\n        });\n      }\n    }\n\n    throw e;\n  }\n}\n\nmodule.exports.requirePlugin = requirePlugin;\n\nfunction getFromString(string) {\n  /**\n   * We allow query strings for plugins, so always split on ?\n   */\n  var split = string.split(\"?\");\n  var outGoing = new Plugin({\n    moduleName: split[0],\n    name: split[0]\n  });\n\n  if (split.length > 1) {\n    return outGoing.update(\"options\", function (opts) {\n      return opts.mergeDeep(qs.parse(split[1]));\n    });\n  }\n\n  return outGoing;\n}","map":{"version":3,"mappings":"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","names":["Immutable","require","Map","isMap","List","qs","path","fs","Plugin","Record","moduleName","name","active","module","undefined","options","via","dir","process","cwd","init","errors","resolvePlugin","item","getFromString","mergeDeep","Error","has","nameOrObj","get","exports","requirePlugin","maybe","resolve","set","e","code","existsSync","update","concat","string","split","outGoing","length","opts","parse"],"sources":["../lib/plugins.js"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}