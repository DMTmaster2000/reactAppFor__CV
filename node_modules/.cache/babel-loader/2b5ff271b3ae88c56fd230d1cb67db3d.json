{"ast":null,"code":"/* eslint-disable consistent-return, no-underscore-dangle */\nconst {\n  parse\n} = require('url');\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst axios = require('axios');\n\nconst debug = require('debug')('localtunnel:client');\n\nconst TunnelCluster = require('./TunnelCluster');\n\nmodule.exports = class Tunnel extends EventEmitter {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(opts);\n    this.opts = opts;\n    this.closed = false;\n\n    if (!this.opts.host) {\n      this.opts.host = 'https://localtunnel.me';\n    }\n  }\n\n  _getInfo(body) {\n    /* eslint-disable camelcase */\n    const {\n      id,\n      ip,\n      port,\n      url,\n      cached_url,\n      max_conn_count\n    } = body;\n    const {\n      host,\n      port: local_port,\n      local_host\n    } = this.opts;\n    const {\n      local_https,\n      local_cert,\n      local_key,\n      local_ca,\n      allow_invalid_cert\n    } = this.opts;\n    return {\n      name: id,\n      url,\n      cached_url,\n      max_conn: max_conn_count || 1,\n      remote_host: parse(host).hostname,\n      remote_ip: ip,\n      remote_port: port,\n      local_port,\n      local_host,\n      local_https,\n      local_cert,\n      local_key,\n      local_ca,\n      allow_invalid_cert\n    };\n    /* eslint-enable camelcase */\n  } // initialize connection\n  // callback with connection info\n\n\n  _init(cb) {\n    const opt = this.opts;\n\n    const getInfo = this._getInfo.bind(this);\n\n    const params = {\n      responseType: 'json'\n    };\n    const baseUri = `${opt.host}/`; // no subdomain at first, maybe use requested domain\n\n    const assignedDomain = opt.subdomain; // where to quest\n\n    const uri = baseUri + (assignedDomain || '?new');\n\n    (function getUrl() {\n      axios.get(uri, params).then(res => {\n        const body = res.data;\n        debug('got tunnel information', res.data);\n\n        if (res.status !== 200) {\n          const err = new Error(body && body.message || 'localtunnel server returned an error, please try again');\n          return cb(err);\n        }\n\n        cb(null, getInfo(body));\n      }).catch(err => {\n        debug(`tunnel server offline: ${err.message}, retry 1s`);\n        return setTimeout(getUrl, 1000);\n      });\n    })();\n  }\n\n  _establish(info) {\n    // increase max event listeners so that localtunnel consumers don't get\n    // warning messages as soon as they setup even one listener. See #71\n    this.setMaxListeners(info.max_conn + (EventEmitter.defaultMaxListeners || 10));\n    this.tunnelCluster = new TunnelCluster(info); // only emit the url the first time\n\n    this.tunnelCluster.once('open', () => {\n      this.emit('url', info.url);\n    }); // re-emit socket error\n\n    this.tunnelCluster.on('error', err => {\n      debug('got socket error', err.message);\n      this.emit('error', err);\n    });\n    let tunnelCount = 0; // track open count\n\n    this.tunnelCluster.on('open', tunnel => {\n      tunnelCount++;\n      debug('tunnel open [total: %d]', tunnelCount);\n\n      const closeHandler = () => {\n        tunnel.destroy();\n      };\n\n      if (this.closed) {\n        return closeHandler();\n      }\n\n      this.once('close', closeHandler);\n      tunnel.once('close', () => {\n        this.removeListener('close', closeHandler);\n      });\n    }); // when a tunnel dies, open a new one\n\n    this.tunnelCluster.on('dead', () => {\n      tunnelCount--;\n      debug('tunnel dead [total: %d]', tunnelCount);\n\n      if (this.closed) {\n        return;\n      }\n\n      this.tunnelCluster.open();\n    });\n    this.tunnelCluster.on('request', req => {\n      this.emit('request', req);\n    }); // establish as many tunnels as allowed\n\n    for (let count = 0; count < info.max_conn; ++count) {\n      this.tunnelCluster.open();\n    }\n  }\n\n  open(cb) {\n    this._init((err, info) => {\n      if (err) {\n        return cb(err);\n      }\n\n      this.clientId = info.name;\n      this.url = info.url; // `cached_url` is only returned by proxy servers that support resource caching.\n\n      if (info.cached_url) {\n        this.cachedUrl = info.cached_url;\n      }\n\n      this._establish(info);\n\n      cb();\n    });\n  }\n\n  close() {\n    this.closed = true;\n    this.emit('close');\n  }\n\n};","map":{"version":3,"names":["parse","require","EventEmitter","axios","debug","TunnelCluster","module","exports","Tunnel","constructor","opts","closed","host","_getInfo","body","id","ip","port","url","cached_url","max_conn_count","local_port","local_host","local_https","local_cert","local_key","local_ca","allow_invalid_cert","name","max_conn","remote_host","hostname","remote_ip","remote_port","_init","cb","opt","getInfo","bind","params","responseType","baseUri","assignedDomain","subdomain","uri","getUrl","get","then","res","data","status","err","Error","message","catch","setTimeout","_establish","info","setMaxListeners","defaultMaxListeners","tunnelCluster","once","emit","on","tunnelCount","tunnel","closeHandler","destroy","removeListener","open","req","count","clientId","cachedUrl","close"],"sources":["/Users/johnberetty/node_modules/localtunnel/lib/Tunnel.js"],"sourcesContent":["/* eslint-disable consistent-return, no-underscore-dangle */\n\nconst { parse } = require('url');\nconst { EventEmitter } = require('events');\nconst axios = require('axios');\nconst debug = require('debug')('localtunnel:client');\n\nconst TunnelCluster = require('./TunnelCluster');\n\nmodule.exports = class Tunnel extends EventEmitter {\n  constructor(opts = {}) {\n    super(opts);\n    this.opts = opts;\n    this.closed = false;\n    if (!this.opts.host) {\n      this.opts.host = 'https://localtunnel.me';\n    }\n  }\n\n  _getInfo(body) {\n    /* eslint-disable camelcase */\n    const { id, ip, port, url, cached_url, max_conn_count } = body;\n    const { host, port: local_port, local_host } = this.opts;\n    const { local_https, local_cert, local_key, local_ca, allow_invalid_cert } = this.opts;\n    return {\n      name: id,\n      url,\n      cached_url,\n      max_conn: max_conn_count || 1,\n      remote_host: parse(host).hostname,\n      remote_ip: ip,\n      remote_port: port,\n      local_port,\n      local_host,\n      local_https,\n      local_cert,\n      local_key,\n      local_ca,\n      allow_invalid_cert,\n    };\n    /* eslint-enable camelcase */\n  }\n\n  // initialize connection\n  // callback with connection info\n  _init(cb) {\n    const opt = this.opts;\n    const getInfo = this._getInfo.bind(this);\n\n    const params = {\n      responseType: 'json',\n    };\n\n    const baseUri = `${opt.host}/`;\n    // no subdomain at first, maybe use requested domain\n    const assignedDomain = opt.subdomain;\n    // where to quest\n    const uri = baseUri + (assignedDomain || '?new');\n\n    (function getUrl() {\n      axios\n        .get(uri, params)\n        .then(res => {\n          const body = res.data;\n          debug('got tunnel information', res.data);\n          if (res.status !== 200) {\n            const err = new Error(\n              (body && body.message) || 'localtunnel server returned an error, please try again'\n            );\n            return cb(err);\n          }\n          cb(null, getInfo(body));\n        })\n        .catch(err => {\n          debug(`tunnel server offline: ${err.message}, retry 1s`);\n          return setTimeout(getUrl, 1000);\n        });\n    })();\n  }\n\n  _establish(info) {\n    // increase max event listeners so that localtunnel consumers don't get\n    // warning messages as soon as they setup even one listener. See #71\n    this.setMaxListeners(info.max_conn + (EventEmitter.defaultMaxListeners || 10));\n\n    this.tunnelCluster = new TunnelCluster(info);\n\n    // only emit the url the first time\n    this.tunnelCluster.once('open', () => {\n      this.emit('url', info.url);\n    });\n\n    // re-emit socket error\n    this.tunnelCluster.on('error', err => {\n      debug('got socket error', err.message);\n      this.emit('error', err);\n    });\n\n    let tunnelCount = 0;\n\n    // track open count\n    this.tunnelCluster.on('open', tunnel => {\n      tunnelCount++;\n      debug('tunnel open [total: %d]', tunnelCount);\n\n      const closeHandler = () => {\n        tunnel.destroy();\n      };\n\n      if (this.closed) {\n        return closeHandler();\n      }\n\n      this.once('close', closeHandler);\n      tunnel.once('close', () => {\n        this.removeListener('close', closeHandler);\n      });\n    });\n\n    // when a tunnel dies, open a new one\n    this.tunnelCluster.on('dead', () => {\n      tunnelCount--;\n      debug('tunnel dead [total: %d]', tunnelCount);\n      if (this.closed) {\n        return;\n      }\n      this.tunnelCluster.open();\n    });\n\n    this.tunnelCluster.on('request', req => {\n      this.emit('request', req);\n    });\n\n    // establish as many tunnels as allowed\n    for (let count = 0; count < info.max_conn; ++count) {\n      this.tunnelCluster.open();\n    }\n  }\n\n  open(cb) {\n    this._init((err, info) => {\n      if (err) {\n        return cb(err);\n      }\n\n      this.clientId = info.name;\n      this.url = info.url;\n\n      // `cached_url` is only returned by proxy servers that support resource caching.\n      if (info.cached_url) {\n        this.cachedUrl = info.cached_url;\n      }\n\n      this._establish(info);\n      cb();\n    });\n  }\n\n  close() {\n    this.closed = true;\n    this.emit('close');\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}